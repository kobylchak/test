Set<E> определяет поведение коллекции, не допускающей дублирования элементов?QQQ+QQQSet<E> c помощью метода equals() заботится об уникальности хранимых объктов.
!!!!!
Соблюдается ли контракт equals() & hashCode() в Set?QQQ+QQQДа, эти методы необходимо переопределять для уникальности элементов.
!!!!!
EnumSet<E> хранит множество объектов из класса Enum?QQQ+QQQQEnumSet<E> хранит множество объектов из класса Enum.
!!!!!
HashSet<E> extends AbstractSet<E> implements Set<E> построен на HashMap и использует хэш-таблицу для хранения элементов?QQQ+QQQЭлементы проходят хеш-функцию, что обеспечивает их уникaльность.
!!!!!
HashSet поддерживает индексацию?QQQ-QQQSet не поддерживает индексацию, зато ecть уникальность за счет equals() и hashCode().
!!!!!
Является ли хеш-код в HashSet ключом, по которому обращаемся к элементу?QQQ+QQQДа, и это ускоряет поиск определенного элемента.
!!!!!
Сохраняются ли элементы в порядке вставки в LinkedHashSet<E>?QQQ+QQQДа, порядок вставки элементов сохраняются после прохождения хеш-функции, в отличии от HashSet<E>.
!!!!!
Получаем ли мы быстрый доступ к элементам в HashSet<E>?QQQ+QQQДа, за счет хеширования.
!!!!!
Зависит ли в HashSet<E> выполнение методов add(), contains(), remove(), size() от размера коллекции?QQQ-QQQНе зависит, потому что объекты, которые хранятся в других бакетах даже рассматриваться не будут.
!!!!!
Бакет - это поддиапазон хеш-таблицы, содержащий связаный список?QQQ+QQQДа, именно так.
!!!!!
Можно ли в HashSet<E> использовать конструктор, принимающий коллекцию?QQQ+QQQДа, за счет этого можем преобразовать List<E> list = new ArrayList<>() в Set<E> set = new HashSet<>(list);
!!!!!
Moжно ли в конструкторе HashSet<E> задавать число ячеек для хранения хеш-кодов?QQQ+QQQДа, Set<E> set = new HashSet(12);
!!!!!
В HashSet<E> по default initial capacity = 12 элементов?QQQ+QQQВ HashSet<E> initial capacity = 16 элементов.
!!!!!
loadFactor - процент наполнености буфера- по default в хеш-таблицах = 0.70?QQQ-QQQНет, default = 75, когда мы на 75 заполнили нашу таблицу, то происходит расширение.
!!!!!
Происходит ли в HashSet<E> расширение capacity по достижению loadFactor?QQQ+QQQДа, сapacity увеличивается в 2 раза ==> будет не 16 элементов, а 32.
!!!!!
HashSet<E> сохраняет порядок добавления элементов?QQQ-QQQЭлементы кешируются и сохраняются в хаотичном порядке.
!!!!!
Позволяет ли HashSet<E> хранить в качестве значения null?QQQ+QQQДа, так же, как и HashMap<K,V> позволяет, но надо быть внимательным, потому что можем получть NullPointerException, если попытаемся у null вызвать какую-то функцию.
!!!!!
В TreeSet<E> элементы сортируются в порядке возрастания, либо можем использовать comparator?QQQ+QQQВ TreeSet<E> элементы сортируются в порядке возрастания, либо можем использовать comparator.
!!!!!
В TreeSet<E> используется реализация красно-черного дерева?QQQ+QQQБинарное дерево.
!!!!!
Можно ли в TreeSet содержать null в качестве элемента?QQQ-QQQВ красно-черном дереве нельзя содержать null в качестве значений - NullPointerException.
!!!!!
Определяет ли SortedSet поведение набора, хранящего элементы в натуральном порядке, заранее определенном для класса?QQQ+QQQДа, передаем компоратор и говорим, как сортировать значения.
!!!!!
SortedSet наследует Set?QQQ+QQQДа, наследует.
!!!!!
Содержиться ли в SortedSet метод headSet(), позволяющий создавать подколлекцию из коллекции?QQQ+QQQSortedSet<E> ss = set.headSet(max_value, true);
!!!!!
LinkedSet extends HashSet, не добавляя никаких новых методов?QQQ+QQQДа, его особенность заключается в том, что класс поддерживает связаный список элементов набора в порядке вставки.
!!!!!
NavigableSet<E> пришел с версии 1.6, позволяет быстро находить элементы, которые больше или меньше указаных?QQQ+QQQДа, за счет таких методов, как celling(), floor(), higher(), lower() ...
!!!!!
NavigableSet<E>ns = new TreeSet<>() правильнее, чем Set<E>set = new TreeSet<>()?QQQ+QQQДа, потому что при вызове некоторых методов, например celling() получим ошибку компиляции.
!!!!!
Возможно ли ограничить максимальный размер добавляемого элемента в  NavigableSet<E>?QQQ+QQQДа, с помощью метода headSet() ==> NavigableSet<Integer> ns = set.headSet(5, true); где 5 - макс. размер элемента, а true = включительно.
!!!!!
Возможно лм в коллекцию NavigableSet<Integer> ns = set.headSet(5, true) добавить элемент ns.add(6)?QQQ-QQQПолучим IllegalArgumentException.
!!!!!