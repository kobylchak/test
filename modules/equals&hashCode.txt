С помощью == сравниваем адресаты ссылок?QQQ+QQQДа.
!!!!!
С помощью метода equals() по умолчанию сравниваем адресаты ссылок?QQQ+QQQДля того, чтобы сравнивать по значению, необходимо переопределить метод equals, следуя некоторым правилам.
!!!!!
рефлексивность - это o1.equals(o1)?QQQ+QQQКогда объект, при условии, что он не null, равен сам себе при многократном вызове.
!!!!!
транзитивность - это o1.equals(o2) ==> o2.equals(o1)?QQQ-QQQНет, это симетричность - если первый объект равен второму объекту, то и второй должен быть равен первому.
!!!!!
симетричность - это o1.equals(o2) && o2.equals(o3) ==> o1.equals(o3)?QQQ-QQQНет, это транзитивность -если первый равен второму, второй равен третему, то это значит, что первый равен третьему.
!!!!!
консистентность - это когда при многокртном вызове o1.equals(o2)?QQQ+QQQДа, говорят еще - устойчивость.
!!!!!
проверка на null - o1.equals(null) ==> false?QQQ+QQQНе должен быть равен true.
!!!!!
Верно ли правило, что для одного и того же объекта хэшкод всегда одинаковый?QQQ+QQQДа, верно. 
!!!!!
Верно ли правило - o1.equals(o2) ==> o1.hashCode() == o2.hashCode()?QQQ+QQQДа, equals() на сравнение объектов true и хэшкоды одинаковые.
!!!!!
Верно ли правило -o1.hashCode() == o2.hashCode() ==> o1.equals(o2)?QQQ-QQQНет, если хэшкоды равны, то объекты не всегда равны - коализия.
!!!!!
Верно ли правило - устойчивость hashCode не изменяется, если объект не изменяется?QQQ+QQQДа, верно.
!!!!!
Верно ли правило - если хэшкоды разные, то и объекты разные?QQQ+QQQДа, верно.
!!!!!
Разрешенно ли перечисления сравнивать по ссылке, как и переменные примитивного типа с помощью ==?QQQ+QQQРазрешенно, потому что перечисления - static, они существуют в единственном экземпляре.
!!!!!
Хешкод возвращает только положительное значение int типа, тоесть от 0 до 2147483647?QQQ-QQQХешкод возвращать значение int типа, как положительные, так и отрицательные, тоесть от -2147484648 до +2147483647.
!!!!!
