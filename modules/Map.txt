Map - карта отображений - объект, который хранит в себе пару "ключ-значение"?QQQ+QQQMap<Key, Value> map = new HashMap<>();
!!!!!
Является ли ключ в Map уникальным?QQQ+QQQДа, за счет переопределения методов equals() и hashCode().
!!!!!
Возможно ли перебрать все ключи Map,учитывая, что Map - не Iterable?QQQ+QQQДа, возможно. С помощью метода Set<K> keySet();
!!!!!
Возможно ли перебрать все значения Map,учитывая, что Map - не Iterable?QQQ+QQQДа, возможно. С помощью метода Collection<V> values();
!!!!!
Возможно ли перебрать все пары ключ-значение в Map, учитывая, что Map - не iterable?QQQ+QQQ Set<Map.Entry<K,V> entrySet()
!!!!!
Если попытаемся в карты вызвать несуществующий элемент будет ли Exception?QQQ-QQQНет, не будет. Вернется null.
!!!!!
Главное отличие HashTable от HashMap заключается в том, что методы класса HashMap в отличии от методов HashTable синхронизированы?QQQ-QQQНаоборот, методы класса HashTable - синхронизированы.
!!!!!
Является ли задачей хеш-функции вычислить индек массива, в котором будет храниться объект на основе содержимого объекта?QQQ+QQQ hashcode & (capacity-1) еще вариант hashcode % capacity.
!!!!!
Является ли HashTable лучше, чем ConcurrentHashMap?QQQ-QQQНет, так как синхронизация в HashTable распространяется на объект(все buckets), a в Сoncurrent только на один bucket.
!!!!!
Является ли класс СoncurrentHashMap реализацией интерфейса ConcurrentMap, который extends Map?QQQ+QQQДа, пришел на замену HashTable.
!!!!!
Mожно ли использовать ConcurrentHashMap при необходимости использовать потокобезопасную коллекцию?QQQ+QQQДа, так как имеет синхронизированые методы.
!!!!!
Верно ли, что все реализации Map extends aбстрактный класс AbstractMap<K,V>, который implements Map<K,V>?QQQ+QQQДа, верно.
!!!!!
Можем ли мы задать свой собственный алгоритм сортировки ключей для TreeMap<K,V>?QQQ+QQQДа, передать Comparator в конструктор.
!!!!!
LinkedHashMap запоминает порядок добавления объектов в карту?QQQ+QQQДа, запоминает, образуя при этом дважды связаный список.
!!!!!

